import { z } from "../deps.ts";

export const packageManifestSchema = z.object({
  //#region Package metadata contained in the abbreviated packument manifests.
  /** Full package name. */
  name: z.string(),
  /** Package version number. */
  version: z.string(),
  /**
   * Distribution info generated by the registry.
   *
   * @see {@link https://github.com/npm/registry/blob/master/docs/responses/package-metadata.md#dist}
   */
  dist: z.object({
    /** Tarball URL. */
    tarball: z.string(),
    /** SHA-1 sum of the tarball. */
    shasum: z.string(),
    /** Subresource integrity. */
    integrity: z.string().optional(),
    /** Number of files in the tarball, folders excluded. */
    fileCount: z.number().optional(),
    /** Total size in bytes of the unpacked files in the tarball. */
    unpackedSize: z.number().optional(),
    /**
     *  PGP registry signature.
     *
     * @see {@link https://docs.npmjs.com/about-pgp-signatures-for-packages-in-the-public-registry}
     */
    "npm-signature": z.string().optional(),
    /**
     * ECDSA registry signatures.
     *
     * @see {@link https://docs.npmjs.com/about-registry-signatures}
     */
    signatures: z.array(z.object({
      keyid: z.string(),
      sig: z.string(),
    })).optional(),
  }).passthrough(),
  /** Deprecation message. */
  deprecated: z.string().optional(),
  /** Production dependencies. */
  dependencies: z.record(z.string()).optional(),
  /** Development dependencies. */
  devDependencies: z.record(z.string()).optional(),
  /** Peer dependencies. */
  peerDependencies: z.record(z.string()).optional(),
  /** Peer dependencies metadata. */
  peerDependenciesMeta: z.record(z.object({
    /** If `true`, this peer dependency is optional. */
    optional: z.boolean(),
  })).optional(),
  /** Optional dependencies. */
  optionalDependencies: z.record(z.string()).optional(),
  /** List of third-party dependencies bundled with this package. */
  bundleDependencies: z.array(z.string()).optional(),
  /** Executable commands installed by the package. */
  bin: z.record(z.string()).optional(),
  /** Directories included in the package. */
  directories: z.record(z.string()).optional(),
  /** Engine runtimes supported by the package. */
  engines: z.record(z.string()).optional(),
  /** CPU architectures supported by the package. */
  cpu: z.array(z.string()).optional(),
  /** Operating systems supported by the package. */
  os: z.array(z.string()).optional(),
  /** If `true`, the package has a shrinkwrap file to be used when installing. */
  _hasShrinkwrap: z.boolean().optional(),
  //#endregion

  //#region Other data generated by the npm registry.
  /** Package version ID (`<name>@<version>`). */
  _id: z.string().optional(),
  /** Node version used when publishing the package. */
  _nodeVersion: z.string().optional(),
  /** npm version used when publishing the package. */
  _npmVersion: z.string().optional(),
  /** npm user who published the package. */
  _npmUser: z.object({
    name: z.string(),
    email: z.string(),
  }).optional(),
  /** npm internal operational data. */
  _npmOperationalInternal: z.object({
    host: z.string(),
    tmp: z.string(),
  }).optional(),
  /** Commit hash for the published version of the package. */
  gitHead: z.string().optional(),
  //#endregion
}).passthrough();

/**
 * `PackageManifest` provides metadata describing a specific version of a package.
 *
 * @see {@link https://github.com/npm/registry/blob/master/docs/responses/package-metadata.md}
 * @see {@link https://github.com/npm/registry/blob/master/docs/REGISTRY-API.md#getpackageversion}
 */
export type PackageManifest = z.infer<typeof packageManifestSchema>;
